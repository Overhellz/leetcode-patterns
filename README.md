# LeetCode Patterns

| Stage | Topic                               | Pattern                                      | Easy          | Medium                                 |   Status    |
|:-----:|:------------------------------------|:---------------------------------------------|:--------------|:---------------------------------------|:-----------:|
|  1.1  | Hash Map                            | Подсчет, группировка                         | 1, 242        | 49, 347, 3, 36, 454, 560, 763, 128     | In Progress |
|  1.2  | Two Pointers                        | #2 Два указателя                             | 125, 283, 344 | 15, 11, 167, 42, 75, 80, 977, 209      |             |
|  1.3  | Sliding Window                      | #3 Скользящее окно                           | 643           | 3, 76, 239, 424, 567, 904, 1004, 1493  |             |
|  1.4  | Linked List                         | #4, #5 Быстрые/медленные указатели, разворот | 206, 21, 14   | 19, 142, 876, 2, 138, 92, 148, 234     |             |
|  1.5  | Stack, Queue                        | #6 Монотонный стек                           | 20, 155       | 739, 853, 496, 503, 84, 227, 394, 735  |             |
|  1.6  | Prefix Sum & Kadane's Algorithm     | #1 Префиксные суммы, Алгоритм Кадана         | 53, 303       | 560, 238, 525, 724, 974, 209, 795, 152 |             |
|  1.7  | Bit Manipulation                    | Битовые операции, маски                      | 191, 190, 136 | 371, 338, 268, 78, 201, 137, 260       |             |
|  1.8  | LRU                                 | Hash Map + Doubly Linked List                | -             | 146, 460                               |             |
| ----- | ----------------------------------- | -------------------------------------------- | ------------- | -------------------------------------- |     ---     |
|  2.1  | Binary Tree, DFS                    | #10, #11 Обход дерева, DFS                   | 104, 112      | 94, 105, 124, 226, 236, 437, 543, 572  |             |
|  2.2  | Binary Tree, BFS                    | #12 BFS                                      | -             | 102, 103, 107, 199, 513, 515, 637, 116 |             |
|  2.3  | Binary Search Tree                  | #9 Модифицированный бинарный поиск           | -             | 98, 230, 235, 450, 701, 108, 173       |             |
|  2.4  | Advanced Binary Search              | #9 Модифицированный бинарный поиск           | -             | 33, 34, 74, 81, 153, 162, 278, 875     |             |
|  2.5  | Heap. Part                          | #7 Топ K элементов                           | -             | 215, 347, 973, 703, 1046               |             |
|  2.6  | Heap. Part 2                        | #7 Топ K элементов                           | -             | 253, 621, 767, 295, 480, 358           |             |
|  2.7  | Intervals                           | #8 Перекрывающиеся интервалы                 | -             | 56, 57, 252, 253, 435, 986, 228, 452   |             |
|  2.8  | Greedy Algorithms                   | Жадные алгоритмы                             | 121, 455      | 55, 45, 122, 134, 406, 435, 621, 763   |             |
|  2.9  | Trie, Autocomplete                  | Префиксное дерево                            | 208           | 211, 212, 1268, 642, 677, 720          |             |
| ----- | ----------------------------------- | -------------------------------------------- | ------------- | -------------------------------------- |     ---     |
|  3.1  | Graph. Intro                        | #11, #12, #13 DFS/BFS/матрицы                | 200, 547      | 695, 733, 130, 417, 994, 109           |             |
|  3.2  | Graph. Part 1                       | #11, #12, #13 DFS/BFS/матрицы                | -             | 207, 210, 323, 261, 133, 399           |             |
|  3.3  | Union Find                          | Связность компонент                          | -             | 547, 684, 323, 261, 128, 130           |             |
|  3.4  | Cycle Detection & Floyd's Algorithm | Обнаружение циклов                           | 14            | 142, 287, 202, 457                     |             |
|  3.5  | Graph. Part 2                       | #11, #12, #13 DFS/BFS/матрицы                | -             | 785, 886, 802, 684, 743                |             |
|  3.6  | Topological sort. Part 1            | Топологическая сортировка                    | -             | 207, 210, 802, 444                     |             |
|  3.7  | Topological sort. Part 2            | Топологическая сортировка                    | -             | 269, 329, 1203, 310                    |             |
|  3.8  | Dijkstra                            | Кратчайшие пути                              | -             | 743, 1514, 1631, 505, 787              |             |
| ----- | ----------------------------------- | -------------------------------------------- | ------------- | -------------------------------------- |     ---     |
|  4.1  | Backtracking. Part 1                | #14 Возврат                                  | -             | 78, 46, 77, 39, 40, 131, 17            |             |
|  4.2  | Backtracking. Part 2                | #14 Возврат                                  | -             | 51, 37, 22, 79, 93, 216, 47            |             |
|  4.3  | Dynamic Programming. Part 1         | #15 Динамическое программирование            | 70, 198       | 322, 300, 1143, 416, 64, 62, 5         |             |
|  4.4  | Dynamic Programming. Part 2         | #15 Динамическое программирование            | -             | 72, 139, 152, 221, 309, 337, 494       |             |

---

# 0. Hash Map

| Level  | Name                                              | Link                                                                          | Status | Repeatable |
|:------:|:--------------------------------------------------|:------------------------------------------------------------------------------|:------:|:----------:|
|  Easy  | 1. Two Sum                                        | https://leetcode.com/problems/two-sum/                                        |  Done  |            |
|  Easy  | 242. Valid Anagram                                | https://leetcode.com/problems/valid-anagram/                                  |  Done  |            |
| Medium | 49. Group Anagrams                                | https://leetcode.com/problems/group-anagrams/                                 |  Done  |            |
| Medium | 347. Top K Frequent Elements                      | https://leetcode.com/problems/top-k-frequent-elements/                        |  Done  |     *      |
| Medium | 3. Longest Substring Without Repeating Characters | https://leetcode.com/problems/longest-substring-without-repeating-characters/ |  Done  |     *      |
| Medium | 36. Valid Sudoku                                  | https://leetcode.com/problems/valid-sudoku/                                   |  Done  |            |
| Medium | 454. 4Sum II                                      | https://leetcode.com/problems/4sum-ii/                                        |  Done  |     *      |
| Medium | 560. Subarray Sum Equals K                        | https://leetcode.com/problems/subarray-sum-equals-k/                          |   .    |            |
| Medium | 767. Reorganize String                            | https://leetcode.com/problems/reorganize-string/                              |        |            |
| Medium | 128. Longest Consecutive Sequence                 | https://leetcode.com/problems/longest-consecutive-sequence/                   |        |            |

```java
// TODO print
// string hash function
public int hash(String str) {
    int[] counts = new int[26];
    for (char c : str.toCharArray()) {
        counts[c - 'a']++;
    }
    return Arrays.hashCode(counts);
}
```

```java
// TODO сортировка массивов 347 
```




-----------------------------------------------
-----------------------------------------------
-----------------------------------------------
-----------------------------------------------
-----------------------------------------------
-----------------------------------------------

1.1 Hash Map (Подсчет, группировка)
Решать: Проверить, являются ли две строки анаграммами.

Группировать: Сгруппировать слова по общим анаграммам.

Найти Top K: Найти K самых частых элементов в массиве.

Найти подмассив: Найти количество подмассивов, сумма которых равна k (используя префиксные суммы и HashMap).

Проверить уникальность: Определить, содержит ли массив повторяющиеся элементы.

1.2 Two Pointers (Два указателя)
Сумма двух: Найти два числа в отсортированном массиве, дающих в сумме заданное значение.

Триплеты: Найти все уникальные тройки в массиве, сумма которых равна нулю.

Вода: Собрать максимальное количество дождевой воды между столбцами.

Разделить цвета: Отсортировать массив из 0, 1 и 2 (Dutch National Flag).

Палиндром: Проверить, является ли строка палиндромом, игнорируя не-буквенные символы.

1.3 Sliding Window (Скользящее окно)
Максимальное среднее: Найти подмассив заданной длины с максимальным средним значением.

Без повторений: Найти длину самой длинной подстроки без повторяющихся символов.

Минимальная подстрока: Найти минимальную по длине подстроку, содержащую все символы другой строки.

Максимум в окне: Найти максимум в каждом скользящем окне фиксированного размера.

Замена символов: Найти длину самой длинной подстроки с одинаковыми буквами после k замен.

1.4 Linked List (Быстрые/медленные указатели, разворот)
Развернуть список: Развернуть односвязный список.

Найти цикл: Обнаружить наличие цикла в списке и найти его начало.

Удалить N-й элемент: Удалить N-й элемент с конца списка.

Середина: Найти средний элемент списка.

Сложить два числа: Сложить два числа, представленных в виде связных списков.

Отсортировать список: Отсортировать связный список (обычно сортировкой слиянием).

1.5 Stack, Queue (Монотонный стек)
Валидность скобок: Проверить корректность последовательности скобок.

Ближайшие элементы: Для каждого элемента найти ближайший меньший/больший элемент слева/справа (температуры).

Минимум в стеке: Реализовать стек, поддерживающий операции push, pop, top и getMin за O(1).

Обратная польская запись: Вычислить значение выражения в обратной польской записи.

Дешифровка строки: Раскодировать строку вида "3[a2[c]]".

1.6 Prefix Sum & Kadane's Algorithm
Максимальный подмассив: Найти подмассив с максимальной суммой (Кадан).

Сумма на отрезке: Реализовать класс для быстрого вычисления суммы элементов массива на отрезке.

Произведение подмассива: Найти подмассив с максимальным произведением.

Количество подмассивов: Найти количество подмассивов с суммой, кратной K.

1.7 Bit Manipulation (Битовые операции, маски)
Подсчет единиц: Подсчитать количество единичных битов в числе.

Одинокое число: Найти число в массиве, которое встречается один раз, а все остальные - дважды.

Степень двойки: Проверить, является ли число степенью двойки.

Подмножества: Сгенерировать все возможные подмножества заданного множества (битовые маски).

Сложение: Сложить два числа без использования операторов + и -.

1.8 LRU (Hash Map + Doubly Linked List)
Реализовать LRU Cache: Реализовать структуру данных Least Recently Used (LRU) cache.

Реализовать LFU Cache: Реализовать структуру данных Least Frequently Used (LFU) cache.

2.1 Binary Tree, DFS (Обход дерева, DFS)
Глубина: Найти максимальную глубину дерева.

Путь до суммы: Проверить существование пути от корня до листа с заданной суммой.

Обходы: Реализовать inorder, preorder и postorder обходы (итеративно и рекурсивно).

Симметрия: Проверить, является ли дерево симметричным.

Предок: Найти наименьшего общего предка двух узлов.

Диаметр: Найти диаметр (самый длинный путь между узлами) дерева.

2.2 Binary Tree, BFS
Обход по уровням: Вернуть узлы, обойденные по уровням (Level Order Traversal).

Zigzag обход: Вернуть узлы в зигзагообразном порядке (слева направо, затем справа налево).

Правый вид: Вернуть значения узлов, видимых справа (Right Side View).

Минимальная глубина: Найти минимальную глубину дерева.

2.3 Binary Search Tree
Валидация: Проверить, является ли дерево валидным BST.

K-й наименьший: Найти K-й наименьший элемент в BST.

Общий предок: Найти наименьшего общего предка двух узлов в BST.

Вставка/Удаление: Вставить/удалить узел в BST.

Сбалансировать: Преобразовать отсортированный массив в сбалансированный BST.

2.4 Advanced Binary Search
Повернутый массив: Найти элемент в отсортированном, но повернутом массиве.

Границы: Найти первое и последнее вхождение элемента в отсортированном массиве.

Мимум в повернутом массиве: Найти минимальный элемент в отсортированном, но повернутом массиве.

Поиск в матрице: Искать элемент в отсортированной по строкам и столбцам матрице.

2.5 Heap. Part 1 (Топ K элементов)
K-й наибольший: Найти K-й наибольший элемент в массиве.

Top K частых: Найти K самых частых элементов.

Ближайшие точки: Найти K ближайших точек к началу координат.

2.6 Heap. Part 2 (Топ K элементов)
Медиана в потоке: Находить медиану из потока данных.

Расписание встреч: Найти минимальное количество конференц-залов, необходимое для проведения всех встреч.

Планировщик задач: Найти минимальное время для выполнения всех задач с cooldown периодом.

2.7 Intervals (Перекрывающиеся интервалы)
Объединить интервалы: Объединить все перекрывающиеся интервалы.

Вставить интервал: Вставить новый интервал в список непересекающихся интервалов.

Пересечения: Найти пересечение двух списков интервалов.

Мимум стрел: Найти минимальное количество стрел, чтобы лопнуть все воздушные шары (интервалы).

2.8 Greedy Algorithms (Жадные алгоритмы)
Лучшее время для покупки: Найти максимальную прибыль от одной сделки.

Прыжки: Проверить, можно ли допрыгать до последнего индекса.

Раздать конфеты: Раздать конфеты детям с учетом рейтинга.

Восстановить очередь: Восстановить очередь по росту, учитывая количество людей спереди, которые выше.

2.9 Trie, Autocomplete (Префиксное дерево)
Реализовать Trie: Реализовать структуру данных Trie (префиксное дерево) с операциями insert, search и startsWith.

Поиск слов: Реализовать поиск слов с возможностью использования точки . (как любого символа).

Поиск слов в сетке: Найти все слова из словаря в символьной сетке (Word Search II).

3.1 Graph. Intro (DFS/BFS/матрицы)
Количество островов: Посчитать количество островов в бинарной сетке.

Заливка (Flood Fill): Реализовать алгоритм заливки.

Количество провинций: Найти количество связанных компонентов в графе.

3.2 Graph. Part 1 (DFS/BFS/матрицы)
Курсы (топсорт): Определить, можно ли пройти все курсы (обнаружение цикла).

Клонировать граф: Создать глубокую копию графа.

Оценка деления: Вычислить результат цепочки уравнений.

3.3 Union Find (Связность компонент)
Количество провинций: Решить задачу на количество связных компонентов.

Избыточное соединение: Найти ребро, которое можно удалить, чтобы граф стал деревом.

Окруженные регионы: "Захватить" регионы, окруженные 'X'.

3.4 Cycle Detection & Floyd's Algorithm
Найти дубликат: Найти повторяющееся число в массиве (модификация задачи на обнаружение цикла).

Начало цикла в списке: Найти узел, с которого начинается цикл в связном списке.

Счастливое число: Определить, является ли число "счастливым".

3.5 Graph. Part 2 (DFS/BFS/матрицы)
Двудольный граф: Проверить, является ли граф двудольным.

Безопасные узлы: Найти все безопасные узлы в графе (ведущие в терминальные узлы).

3.6-3.7 Topological sort
Курсы I & II: Найти порядок прохождения курсов, если это возможно.

Порядок букв в словаре: Восстановить порядок букв в инопланетном словаре.

Минимальная высота деревьев: Найти все корни деревьев с минимальной высотой.

3.8 Dijkstra (Кратчайшие пути)
Задержка сети: Найти время, через которое все узлы получат сигнал.

Минимальные усилия: Найти путь с минимальными максимальными усилиями.

Дешевые перелеты: Найти самый дешевый путь с ограничением на количество пересадок.

4.1-4.2 Backtracking (Возврат)
Подмножества: Сгенерировать все возможные подмножества заданного множества.

Перестановки: Сгенерировать все возможные перестановки массива (с уникальными и дублирующимися числами).

Комбинации: Найти все комбинации чисел, дающих в сумме заданное значение.

Разделение палиндрома: Разделить строку на все возможные палиндромы.

N ферзей: Разместить N ферзей на доске N×N так, чтобы они не атаковали друг друга.

Поиск слов в сетке: Проверить, существует ли слово в символьной сетке.

4.3-4.4 Dynamic Programming (Динамическое программирование)
Числа Фибоначчи: Подняться по лестнице (кол-во способов).

Взлом дома: Максимизировать сумму, которую можно украсть, не взламывая два соседних дома.

Размен монет: Найти минимальное количество монет для размена суммы.

Наибольшая общая подпоследовательность (LCS): Найти длину LCS двух строк.

Рюкзак (0/1): Можно ли разделить массив на две части с равной суммой?

Минимальный путь в сетке: Найти минимальную сумму пути из верхнего левого угла в нижний правый.

Редакционное расстояние: Найти минимальное количество операций для приведения одной строки к другой.

Максимальный квадрат: Найти максимальный квадрат, состоящий из единиц, в бинарной матрице.

Палиндромная подстрока: Найти самую длинную палиндромную подстроку в строке.

хорошо, теперь к каждой теме нужно подобрать наиболее часто встречающиеся и наиболее подходящие или обязательные для прорешивания 1-3 задачи на Leetcode уровня easy или medium. Нужно только указать номер задачи после темы
Отлично, вот список ключевых тем с 1-3 наиболее важными и часто встречающимися на собеседованиях задачами уровня Easy/Medium.

Base Patterns
1.1 Hash Map (Подсчет, группировка)

49

1

347

1.2 Two Pointers

15

11

42

1.3 Sliding Window

3

76

239

1.4 Linked List (Быстрые/медленные указатели, разворот)

206

141

21

1.5 Stack (Монотонный стек)

20

155

739

1.6 Prefix Sum & Kadane's Algorithm

53

560

238

1.7 Bit Manipulation

191

136

268

1.8 LRU Cache

146

Binary Tree & Searching
2.1 Binary Tree, DFS

104

94

226

2.2 Binary Tree, BFS

102

199

2.3 Binary Search Tree

98

230

2.4 Advanced Binary Search

33

34

2.5 Heap (Топ K)

215

347

2.7 Intervals

56

57

2.8 Greedy Algorithms

121

55

2.9 Trie

208

211

Graphs
3.1 Graph. Intro (DFS/BFS)

200

547

3.2 Graph. Part 1 (Топсорт, циклы)

207

210

3.3 Union Find

547

684

3.4 Cycle Detection (Floyd)

142

287

3.5 Graph. Part 2 (Двудольность)

785

3.8 Dijkstra

743

Advanced Techniques
4.1 Backtracking. Part 1

78

46

4.2 Backtracking. Part 2

79

22

4.3 Dynamic Programming. Part 1

70

322

300

4.4 Dynamic Programming. Part 2

139

5